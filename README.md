# Notice 

At the moment this is **alpha** software. While everything appears to work (on my Windows 10 registry at least), there is no guarantee that it will work the registry hive you are examining. The binary format for the registry is not public, can change without notice, and may behave in ways that are not documented anywhere. 

**At the moment regtools does not support deserializing `bd` or "Big Data" values.** None of the registry hives I have examined **have** any big data values as far as I can tell, so while it would be very easy to implement this, I need to find a registry file that definitely does contain them in order to test/develop the feature. 

# regtools

`regtools` is a command-line utility + tiny, simple scripting language (written in Haskell) for exploring Windows registry hive bins (binary) files. Its features include an interactive shell for live exploration of registry keys and values, a plugin system to facilitate sharing and rerunning queries, the ability to output the results of queries (or the entire registry, if you really hate having free disk space) to JSON, and a tool for hashing select registry keys. 

You should be able to compile + run `regtools` on any modern linux platform. It *may* compile on Windows (there are no platform-specific libraries) but is not actively targeted at Windows at this time.

### Requirements 

`regtools` attempts to parse the entirety of a windows registry hive and load it into memory before running queries on it. You'll need at least as much free RAM (probably around 2x as much from rough htop guesstimation) as the size of the file you are loading. You *probably* have more than enough RAM, but don't try to run it on a toaster. 

It scales pretty well with the number of cores you have. On my Ryzen 3900x, it takes about 3 seconds to deserialize a 45mb hive file with all 12 cores, and around 30 with only one core. 

### Installation 

To install `regtools` you will first need a version of the Glasgow Haskell Compiler (GHC) and the Haskell Stack (stack) package manager. 

It is highly suggested that you obtain a copy of GHC and stack via the 
ghcup[https://www.haskell.org/ghcup/] Haskell installer. (Especially if you are on Arch Linux.) 

Once you have that installed, clone the reposity and then: 

```
cd regtools
stack install
```

You might want to go make a sandwich or something - it'll take a while to compile the dependencies. If you don't see any error messages when you get back, you should now have a copy of regtools installed on your path. (If not, it's probably a stack configuration problem, see here[https://docs.haskellstack.org/en/stable/GUIDE/] for assistance.)

### Usage 

`regtools` has three modes of operation:

1) **Shell mode**, which provides an interactive shell for exploring the registry, and can be accesed via:

```
regtools -i "/path/to/hive/bin" shell 
```

2) **Plugin mode**, which reads a regtools plugin file and outputs the results to a file of your choice:

```
regtools -i "/path/to/hive/bin" plugin "/path/to/plugin/file" "/path/to/output/file"
```

3) **Hash check mode**, which reads a hash of registry keys generated by `regtools` and prints the result to the terminal: 

```
regtools -i "/path/to/hive/bin" chkhash "/path/to/hash/file"
```

## Syntax 

`regtools` provides a (very) small DSL for querying a registry hive, printing the results. The syntax is inspired by bash style pipes. Here's an example of a `regtools` query: 

```
query root (subkeys | select (keyName "Software") | concatMap (subkeys) | select (keyName "Adobe") | print)
     a        b               c                            d                      e                    f
```

This is a *query expression*. All query expressions have the form:

```
query <focus> (viewer1 arg1 | viewer2 arg2 arg3 | <etc>)
``` 

The `<focus>` is either a variable (see the section on *Assignments*), or `root`. (Most of the time it will be `root`.)

`viewer1`, `viewer2`, etc are *view functions*, which are chained together with `|` in the manner of bash scripts. The output of `viewer1` is fed into `viewer2`, and the output of that is fed into `viewer3` if there is one, etc. 

(Terminological note: `arg1`, `arg2` etc are the *arguments* to the view function, whereas the output of the previous view function (or the focus if it is the first view function) are *input*.)

Here's what the example query expression does: 

a) `query root` indicates that the query will be run against the root (first, top-level) key of a registry. Because this "focuses" on the root query, we call `root` the **focus**. 

b) `subkeys` focus on a *list* of all of the subkeys of its input. Since we are focusing on the root key, it gives us all of the (immediate) subkeys of the root key. 

c) `select (keyName "Software")` (parentheses are mandatory with `select`) operates on a *list* of keys and removes every key from the list that does not satisfy the condition of its argument. 

`keyName` takes a string as its argument and **matches on any key in the input list which contains the string in its name**. I.e. it performs substring search on the key names it is inspecting.

**keyName's argument is case sensitive**

d) `concatMap` *takes a view function that produces a list* as its argument, and a *list* as its input, and produces a *list* as its output. The main point of this is to avoid having to deal with lists of lists of lists (of lists...). It might seem complicated at first but it's really not so bad. 

Here, `concatMap (subkeys)` (the parentheses aren't optional for `concatMap`) takes the `subkeys` view function as an argument, which has a single key as its input and produces a list of keys as its output, and applies `subkeys` to every key in its input list, then "squishes" the list of lists into a list. 

e) Same thing as C. Remember: Performs a substring search on all keys in a list of keys and filters out those that do not contain the string "Adobe"

f) `print` doesn't take any arguments and prints the output to the terminal in (hopefully) a well-formatted and easy to read form. 

As an example, running the above query on my Windows partition's `hkeyClassesRoot` hive gives the following output: 

```
> query root (subkeys | select (keyName "Software") | concatMap (subkeys) | select (keyName "Adobe") | print)

[
| Key Name: Adobe
| Path: S-1-5-21-3199533274-2294187411-1904285961-1001_Classes\Software\
| TimeStamp:  Sat, 13 Mar 2021 14:01:34 UTC
| Values: <NONE>
| Subkeys: <TRUNCATED>
|------]
```


