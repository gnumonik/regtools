# Notice 

At the moment this is **alpha** software. While everything appears to work (on my Windows 10 registry at least), there is no guarantee that it will work the registry hive you are examining. The binary format for the registry is not public, can change without notice, and may behave in ways that are not documented anywhere. 

**At the moment regtools does not support deserializing `bd` or "Big Data" values.** None of the registry hives I have examined **have** any big data values as far as I can tell, so while it would be very easy to implement this, I need to find a registry file that definitely does contain them in order to test/develop the feature. 

# regtools

`regtools` is a command-line utility + tiny, simple scripting language (written in Haskell) for exploring Windows registry hive bins (binary) files. Its features include an interactive shell for live exploration of registry keys and values, a plugin system to facilitate sharing and rerunning queries, the ability to output the results of queries (or the entire registry, if you really hate having free disk space) to JSON, and a tool for hashing select registry keys. 

You should be able to compile + run `regtools` on any modern linux platform. It *may* compile on Windows (there are no platform-specific libraries) but is not actively targeted at Windows at this time.

### Requirements 

`regtools` attempts to parse the entirety of a windows registry hive and load it into memory before running queries on it. You'll need at least as much free RAM (probably around 2x as much from rough htop guesstimation) as the size of the file you are loading. You *probably* have more than enough RAM, but don't try to run it on a toaster. 

It scales pretty well with the number of cores you have. On my Ryzen 3900x, it takes about 3 seconds to deserialize a 45mb hive file with all 12 cores, and around 30 with only one core. 

### Installation 

To install `regtools` you will first need a version of the Glasgow Haskell Compiler (GHC) and the Haskell Stack (stack) package manager. 

It is highly suggested that you obtain a copy of GHC and stack via the 
ghcup[https://www.haskell.org/ghcup/] Haskell installer. (Especially if you are on Arch Linux.) 

Once you have that installed, clone the reposity and then: 

```
cd regtools
stack install
```

You might want to go make a sandwich or something - it'll take a while to compile the dependencies. If you don't see any error messages when you get back, you should now have a copy of regtools installed on your path. (If not, it's probably a stack configuration problem, see here[https://docs.haskellstack.org/en/stable/GUIDE/] for assistance.)

### Usage 

`regtools` has three modes of operation:

1) **Shell mode**, which provides an interactive shell for exploring the registry, and can be accesed via:

```
regtools -i "/path/to/hive/bin" shell 
```

2) **Plugin mode**, which reads a regtools plugin and runs it:

```
regtools -i "/path/to/hive/bin" plugin "/path/to/plugin/file" 
```

3) **Hash check mode**, which reads a hash of registry keys generated by `regtools` and prints the result to the terminal: 

```
regtools -i "/path/to/hive/bin" chkhash "/path/to/hash/file"
```

## Syntax 

### Queries & View Functions 

`regtools` provides a (very) small DSL for querying a registry hive, printing the results. The syntax is inspired by bash style pipes. Here's an example of a `regtools` query: 

```
query root (subkeys | select (keyNameHas "Software") | concatMap (subkeys) | select (keyNameHas "Adobe") )
     a        b               c                            d                      e                    
```

This is a *query expression*. All query expressions have the form:

```
query <focus> (viewer1 arg1 | viewer2 arg2 arg3 | <etc>)
``` 

The `<focus>` is either a variable (see the section on *Assignments*), or `root`. (Most of the time it will be `root`.)

`viewer1`, `viewer2`, etc are *view functions*, which are chained together with `|` in the manner of bash scripts. The output of `viewer1` is fed into `viewer2`, and the output of that is fed into `viewer3` if there is one, etc. 

(Terminological note: `arg1`, `arg2` etc are the *arguments* to the view function, whereas the output of the previous view function (or the focus if it is the first view function) are *input*.)

Here's what the example query expression does: 

a) `query root` indicates that the query will be run against the root (first, top-level) key of a registry. Because this "focuses" on the root query, we call `root` the **focus**. 

b) `subkeys` focus on a *list* of all of the subkeys of its input. Since we are focusing on the root key, it gives us all of the (immediate) subkeys of the root key. 

c) `select (keyNameHas "Software")` (parentheses are mandatory with `select`) operates on a *list* of keys and removes every key from the list that does not satisfy the condition of its argument. 

`keyName` takes a string as its argument and **matches on any key in the input list which contains the string in its name**. I.e. it performs substring search on the key names it is inspecting.

**keyName's argument is case sensitive**

d) `concatMap` *takes a view function that produces a list* as its argument, and a *list* as its input, and produces a *list* as its output. The main point of this is to avoid having to deal with lists of lists of lists (of lists...). It might seem complicated at first but it's really not so bad. 

Here, `concatMap (subkeys)` (the parentheses aren't optional for `concatMap`) takes the `subkeys` view function as an argument, which has a single key as its input and produces a list of keys as its output, and applies `subkeys` to every key in its input list, then "squishes" the list of lists into a list. 

e) Same thing as C. Remember: Performs a substring search on all keys in a list of keys and filters out those that do not contain the string "Adobe"

(See the reference at the end of this file for an explanation of all of the commands.)

### Commands & Variable Assignment 

If you run the example query in the previous section, you will notice that it does not produce any output to the terminal. This is intentional! Some queries may return a very large number of results, and it would take far longer to print them to the terminal than it takes the computer to calculate them. 

To print the output to the terminal, you can use the (appropriately named) `print` command like so: 

```
> print (query root (subkeys | select (keyNameHas "Software") | concatMap (subkeys) | select (keyNameHas "Adobe") ) )

[
| Key Name: Adobe
| Path: S-1-5-21-3199533274-2294187411-1904285961-1001_Classes\Software\
| TimeStamp:  Sat, 13 Mar 2021 14:01:34 UTC
| Values: <NONE>
| Subkeys: <TRUNCATED>
|------]
```

But that's kind of ugly and the parentheses make it hard to read, so, alternatively, you can **assign the result of a query to a variable** like so: 

```
> x <- query root (subkeys | select (keyNameHas "Software") | concatMap (subkeys) | select (keyNameHas "Adobe") )

> print x

[
| Key Name: Adobe
| Path: S-1-5-21-3199533274-2294187411-1904285961-1001_Classes\Software\
| TimeStamp:  Sat, 13 Mar 2021 14:01:34 UTC
| Values: <NONE>
| Subkeys: <TRUNCATED>
|------]
```

One thing to note here is that the `regtools` scripting language is **strongly/statically typed**. If you don't know what the means (or are scared of types), don't worry! There are *only **5*** types: 
     1) `REGKEY`, which represents a registry key  
     2) `VAL`, which represents a registry value  
     3) `BOOL` (i.e. True/False) 
     4) `LIST`s, e.g. `LIST REGKEY` or `LIST VAL`. Lists in `regtools` must contain elements which are all the same type.
     
The 5th type is called `EFFECT` and you can mostly ignore it. (If you're familiar with functional programming, it's equivalent to `()` in Haskell or `unit` in purescript or... I forget what it's called in Scala. `regtools` commands are just expressions that return `EFFECT`.) This is the return type of commands and exists for the purposes of keeping the internal type system coherent. 

**You do not ever have to annotate the type. Indeed, it is impossible to do so!** `regtools` can deduce the type of every valid expression. If you aren't sure what the type of an expression is , you can use the `showType` command in the shell, and `regtools` will tell you the type: 

```
> x <- query root (subkeys | select (keyNameHas "Software") | concatMap (subkeys) | select (keyNameHas "Adobe") )

> showType x

LIST REGKEY
``` 

This tells you that the variable `x` refers to a *list of RegistryKey values*. Note that checking the type like this does not "run" (evaluate) the expression. 

For the most part, all you need to keep track of is whether your expressions return a Registry Key, a list of Registry Keys, or a list of Registry Values. 

Other than `print`, the other `regtools` commands are: 

`writeJSON`, which takes two mandatory arguments and one optional argument. The first (mandatory) argument is a variable or expression that returns a Registry Key, a list of keys, or a list of values. (Technically you can also write BOOLs to a file, but I'm not sure what the point would be.) The second mandatory argument is the output file path to write the JSON representation of a Key/List of Keys/List of Values. The third (optional) argument is a string which you can use to tag the JSON object. For example: 


